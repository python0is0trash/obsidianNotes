# ПОЛУЧЕНИЕ ДОСТУПА К ДАННЫМ ПОЛЬЗОВАТЕЛЯ С ПОМОЩЬЮ ОБХОДА БЛОКИРОВОК
___

> [!Замечание]
> Подразумевается, что нужно получить доступ либо к удаленной машине, либо к локальной, не работая напрямую с аппаратным обеспечением исследуемого устройства (например, вынимая НЖМД)
## Защита удаленного подключения по SSH
### Часть 1. Предварительное сканирование сети

```bash title:"Использование nmap"
sudo nmap -sV -O -A 192.168.214.78 # порты, операционка
```

Далее следует использовать утилиты `enum4linux`, `impacket`, `metasploit` для предварительного анализа удаленной машины.
### Часть 2. Теория
#### 1) PAM

> Может применяться **модульная защита PAM** (*Pluggable Authentication Modules*) - она позволяет пользователям авторизоваться любым доступным способом, абстрагировавшись от самого процесса аутентификации. PAM используется везде, где требуется аутентификация пользователя или проверка его прав. PAM разделяет процесс аутентификации на модули, которые можно настраивать и комбинировать в зависимости от требований системы.

Модули PAM хранятся в `/usr/lib/x86_64-linux-gnu/security/`, конфигурационные файлы PAM - в `/etc/pam.d`, а конфигурационные файлы модулей - в `/etc/security`.

1. **Модули PAM** - это отдельные библиотеки (обычно файлы `.so`), которые выполняют конкретные задачи, связанные с аутентификацией, управлением учетными записями, сессиями и паролями. Каждый модуль отвечает за определенную функцию (например, `pam_unix.so` - стандартный модуль для работы с паролями в `/etc/shadow`), например:
	- **Аутентификация** (проверка пароля и т.д.).
	- **Управление учетными записями** (проверка, активен ли пользователь, истек ли срок действия учетной записи и т.д.).
	- **Управление сессиями** (создание и завершение сеансов пользователя).
	- **Управление паролями** (изменение или сброс паролей).
2. **Конфигурационные файлы PAM** определяют, какие модули и в каком порядке будут использоваться для конкретного сервиса или приложения. Эти файлы обычно называются по имени сервиса (например, `login`, `sshd`, `sudo`). Каждый конфигурационный файл состоит из строк, которые определяют, как PAM должен обрабатывать запросы. Строки имеют следующий формат:

```text title:"Формат строк КФ PAM"
<тип_контроля> <модуль> <аргументы> где:

Тип контроля:
	auth — аутентификация пользователя.
	account — проверка учетной записи (например, доступна ли учетная запись).
	session — управление сессией (например, логирование входа).
	password — управление паролями.
Модуль — имя модуля PAM (например, pam_unix.so).
Аргументы — параметры, передаваемые модулю.
```

Пример КФ PAM:

```bash title:/etc/pam.d/cron
# The PAM configuration file for the cron daemon

@include common-auth

# Sets the loginuid process attribute
session    required     pam_loginuid.so

# Read environment variables from pam_env's default files, /etc/environment
# and /etc/security/pam_env.conf.
session       required   pam_env.so

# In addition, read system locale information
session       required   pam_env.so envfile=/etc/default/locale

@include common-account
@include common-session-noninteractive 

# Sets up user limits, please define limits for cron tasks
# through /etc/security/limits.conf
session    required   pam_limits.so
```

3. Некоторые модули PAM имеют **свои собственные конфигурационные файлы**. Конфигурационные файлы модулей **настраивают поведение отдельных модулей**.

```bash title:group.conf
#
# This is the configuration file for the pam_group module.
#

#
# *** Please note that giving group membership on a session basis is
# *** NOT inherently secure. If a user can create an executable that
# *** is setgid a group that they are infrequently given membership
# *** of, they can basically obtain group membership any time they
# *** like. Example: games are allowed between the hours of 6pm and 6am
...
```

> [!Подытог]
> Когда пользователь пытается войти в систему через ssh, происходит следующее:
> 1. Система **проверяет конфигурационный файл** `/etc/pam.d/sshd`.
> 2. В зависимости от настроек, PAM **вызывает модули для аутентификации** (например, `pam_unix.so` для проверки пароля).
> 3. Если аутентификация успешна, PAM **проверяет учетную запись** (например, не заблокирована ли она).
> 4. После успешного входа PAM **управляет сессией пользователя**.
#### 2) sudoers

> Ещё есть **sudoers** - конфигурационные файлы, в которых описано, каким пользователям разрешено повышать свои привилегии при помощи команды `sudo`. Основный конфигурационный файл `sudoers` находится по пути `/etc/sudoers`, а дополнительные конфиги в `/etc/sudoers.d/`.
### Часть 3. Обход
#### 1) Как может быть обеспечена защита
1. **Перевод SSH на нестандартный порт** - самая простая, но в то же время самая слабая мера защиты. Обход: требуется просканировать систему на предмет открытых портов и выяснить, какой из них слушает SSH.
2. **Запрет входа под пользователем root параметром `PermitRootLogin` в файле `/etc/ssh/sshd_config`.** Мера эффективна в сочетании с хорошо настроенной конфигурацией sudoers, где у пользователей и их процессов нет доступа к опасным командам. Даже при входе на сервер пользователь не сможет серьёзно навредить системе, так как это невозможно без root-прав.
3. **Запретит входа по паролю параметром `Password/Authentication` в config-е SSH-сервера.** Данная мера спасает от брутфорса и утечки паролей пользователей. Если приватный ключ зашифрован паролем, взломать его практически невозможно.
4. **Настройка двухфакторной аутентификации через SSH.** Пользователь сможет подключиться к серверу только если правильно введёт пароль, приватный ключ или одноразовый код, меняющийся каждые 30 секунд. 
#### 2) Практическая реализация
##### 1. Обход парольной защиты (брутфорс)

```bash
hydra -L users.txt -P passwords.txt 192.168.1.10 smb
medusa -U users.txt -P passwords.txt -h 192.168.1.10 -M ssh
```
##### 2. Если получен публичный ключ

```bash
ssh -i rsa-key -p 22 root@10.20.30.40

или

ssh-add user
*password*
```
##### 3. Старые версии Linux
Использование уязвимости `CVE-2008-0166`.
##### 4. Другое
Другие способы обхода блокировки по ssh не представляют интереса, поскольку обычно система не предоставляет доступа к файловой системе без ввода необходимых данных для авторизации или ограничивают входящий сетевой трафик.
### Ссылки
[Habr PAM](https://habr.com/ru/companies/slurm/articles/694222/)
[SSH Agent](https://habr.com/ru/companies/ruvds/articles/762320/)
## [[Исследование операционных систем/Linux/Пароли и шифрование/Парольная аутентификация#Обход парольной защиты|Обход парольной защиты]]
## Обход шифрования

> [!Важно]
> Ниже представлены ссылки на описание полнодискового и файлового шифрования на примере встроенных в большинство дистрибутивов Linux утилит. Сторонние утилиты шифрования работают по схожему алгоритму, единственное отличие заключается в используемых алгоритмах шифрования.
### Часть 1. [[Исследование операционных систем/Linux/Пароли и шифрование/Шифрование#LUKS (Linux Unified Key Setup)|Полнодисковое шифрование]]
### Часть 2. [[Исследование операционных систем/Linux/Пароли и шифрование/Шифрование#eCryptfs|Файловое шифрование]]

## Сброс парольной защиты BIOS/UEFI

> [!NOTE] Для чего нужен пароль BIOS/UEFI
> **Пароль BIOS/UEFI** - это механизм защиты, который ограничивает доступ к настройкам BIOS или UEFI. Этот пароль требуется для входа в интерфейс настройки BIOS/UEFI, а в некоторых случаях - для загрузки операционной системы. Информация о пароле 

1. Вытащить и поставить обратно батарейку CMOS (или питание батареи на ноутбуке).
2. Замкнуть соответствующие контакты на материнской плате (или использовать соответствующую кнопку на материнской плате).
3. [Использование инженерных кодов и загрузку DOS](https://habr.com/ru/articles/128466/) - для старых систем.
4. В случае хранения информации о пароле в микросхемах BIOS/UEFI или NVRAM - перепрошивка микросхемы BIOS/UEFI через программатор.
5. Использование мастер-пароля производителя материнской платы.
# СПОСОБЫ ВНЕДРЕНИЯ ПО
___

> [!NOTE] Важно
> Описываются только методы внедрения ПО без физического доступа к системе (за исключением последнего случая). Еще указанные методы могут быть комбинированными (например, использование некритической уязвимости для установки логической бомбы, которая в будущем будет активировать бэкдор), а также использоваться совместно с сетевыми атаками. Клонирование фалов в системе и полиморфизм ПО повышает устойчивость к уничтожению.
> 
> Примечание: книга на тему ВПО - *Программные и аппаратные трояны (в 2х частях), A. И. Белоус, B. А. Солодуха, С В. Шведов*.
## Часть 1. Скачанные файлы (в том числе через переполнение буфера)
1. ПО может **внедряться в архивы** (в т. ч. самораспаковывающиеся, например, джойнеры - *joiner*) или **шифрованные контейнеры**, внутри которых САВЗ или другие средства защиты не смогут распознать подозрительные файлы ([Docker Escape](https://habr.com/ru/companies/first/articles/650553/)).
2. Использование **обфускации**, а также некоторых **механизмов подмены процессов**, таких как [*Process Hollowing* или *Process Doppelganging*](https://habr.com/ru/articles/755344/).
3. **Подмена легитимных файлов (библиотек, файлов команд),** необходимых для работы системы (то есть внедряется легитимное ПО вместе с нелегитимным, последнее впоследствии заменяет, например, системную библиотеку, и легитимное ПО запускает процесс, использующие замененный файл).
4. **Модификация прошивки** дисков.
## Часть 2. Дополнения к приложениям
Используются **скачанные макросы, плагины, расширения** для конкретных приложений, которые **несут полезную нагрузку**.
## Часть 3. Уязвимости версий
Каждая система имеет уязвимости (например, ошибка в реализации протокола проверки сертификатов TLS от компании Apple или уязвимость генератора псевдослучайной последовательности `DUAL_EC_DRBG`). Именно поэтому перед началом атаки **следует досконально изучить систему** (например, с помощью сетевых анализаторов) на предмет установленного ПО (в том числе их версий), служб, обновлений системы, библиотеках и так далее, а **затем использовать полученную информацию** для атаки.
## Часть 4. [Drive-by атаки](https://www.kaspersky.ru/resource-center/definitions/drive-by-download)
В обычном сценарии через **взаимодействие пользователя с зараженным сайтом** (например, путем изменения его кода) запускается определенный скрипт.
## Часть 5. Другие виды атак
1. [**Атака количеством.**](https://encyclopedia.kaspersky.ru/knowledge/how-malware-penetrates-systems/) Генерация и распространение в интернете большого количества новых версий троянских программ за короткий промежуток времени. В результате антивирусные компании оказываются «завалены» новыми образцами, на анализ которых требуется время, что даёт злоумышленному коду дополнительный шанс для успешного внедрения в компьютеры.
2. **Модификация загрузчика**, благодаря которой ПО не обнаруживается никак.
3. Использование символов [Unicode для именования файлов](https://moluch.ru/archive/115/30348/) (например, символ RLO) - для старых систем.
4. Использование **необычных сигнатур** файлов.
5. Использование [**CVE-уязвимостей**](https://github.com/search?q=cve%20linux&type=repositories) для Linux (например, CVE-2016-5195).
## Часть \*. Физический доступ
1. Загрузка с **LiveUSB**;
2. Подключение накопителя **к другому устройству** (не рекомендуется);
3. Использование **специальных устройств**, имитирующих базовые устройства (например, клавиатуру) - *Rubber Ducky*, аппаратных закладок, троянов, средств электронного воздействия;
# ОБХОД САВЗ И ИЗМЕНЕНИЕ ПОЛИТИКИ БЕЗОПАСНОСТИ
___

> [!NOTE] Важно
> Помимо способов, описанных [[#СПОСОБЫ ВНЕДРЕНИЯ ПО|выше]], существует также ряд других более продвинутых механизмов обхода, о которых пойдет речь ниже.
> 

## Часть 1. Обход САВЗ
1. Использование **технологий ИИ** для анализа целевой системы и изменения поведения программы на этой основе (сюда также можно включить **анализ среды, в которой была запущена программа**, например, в песочнице или на виртуальной машине).
2. **Обфускация, контейнеризация, шифрование кода** и тому подобные техники изменения исходного кода программы (включая перехват вызова определенных функций).
3. **Загрузка кода в память** процессов ([Process Hollowing и Process Doppelganging](https://habr.com/ru/articles/755344/), [DLL Injection](https://habr.com/ru/companies/otus/articles/761890/), [Reflective DLL Loading](https://habr.com/ru/companies/otus/articles/762680/)) или **код приложений** (вредоносный скрипт может быть добавлен в cron-задачи или запущен как служба через `systemd`).
4. **Rootkits** и **Bootkits**, перезаписывающие загрузочную область диска, тем самым получая полный контроль над системой.
5. **Подмена сертификатов** приложений, **замена системных файлов** и **использование легитимных инструментов**.
6. **Поли- и метаморфизм** ([ссылка](https://www.securitylab.ru/analytics/288278.php)).
7. **Загрузка программы непосредственно в физическую память**, минуя основную.
8. [**Многоступенчатые атаки**](https://encyclopedia.kaspersky.ru/glossary/infection-chain/).
9. Замена **путей PATH**.
10. Использование **расширенных атрибутов** файлов (например, атрибут `immutable` (`+i`) может предотвратить удаление файла, или ПО может хранить свои данные в расширенных атрибутах, которые не проверяются стандартными антивирусами).
## Часть 2. Внесение ПО в список разрешенных САВЗ

> [!NOTE] Предварительная загрузка
> Как и любой другой механизм, этот также подразумевает предварительную загрузку какого-либо кода на целевое устройство (чаще всего это самый сложный этап атаки). Так, перед тем, как ПО попытается добавить что-либо в список разрешенных САВЗ, оно должно каким-либо образом проникнуть в систему, о способах было описано в [[#Часть 1. Обход САВЗ|ч. 1]] и в главе [[#СПОСОБЫ ВНЕДРЕНИЯ ПО]]. 

1. **Ручное добавление** пользователем (яркий пример - при использовании "пиратского" ПО).
2. Использование **легитимных утилит** (например, команд bash).
3. **Эксплуатация уязвимостей** САВЗ и других приложений.
# ФАЙЛЫ, СОДЕРЖАЩИЕ ИНФОРМАЦИЮ О ДЕЙСТВИЯХ ПОЛЬЗОВАТЕЛЯ
___
### Организованный просмотр
###### [journalctl](https://losst.pro/shpargalka-po-journalctl-v-linux)
Удобным инструментом анализа логов на живой системе является утилита `journalctl`. Это утилита командной строки, входящая в состав `systemd` , которая позволяет просматривать и анализировать системные журналы, создаваемые компонентом `journald` . Эти журналы содержат **информацию о событиях, происходящих в системе**, включая **загрузку ядра, работу служб, аутентификацию пользователей, ошибки приложений** и многое другое. По умолчанию `journald` перезаписывает свои журналы логов при каждой перезагрузке, и вызов `journalctl` выведет журнал логов начиная с текущей загрузки системы. Файл конфигурации находится по пути `/etc/systemd/`.
###### [lazyjournal](https://github.com/Lifailon/lazyjournal)
Используется для чтения журналов из `journalctl`, файловой системы, контейнеров Docker и Podman, а также модулей Kubernetes для быстрого просмотра и фильтрации с нечетким поиском, поддержкой регулярных выражений и раскраской выходных данных, написанных на Go с использованием gocui.

```bash title:Установка
apt install gccgo-go
apt install golang-go

git clone https://github.com/Lifailon/lazyjournal
cd lazyjournal
go run main.go
```
###### `find / -name \*.log -ls | sort -r -n -k7 | awk '{print $NF}'`
Файлы с расширением .log (также можно искать по ключевым словам, например, `.\*` - скрытые файлы, `\*history\*` - файлы, возможно, относящиеся к истории поиска или просмотра чего-либо).
### Расположение логов
###### Расположение логов системы (могут свидетельствовать о действиях пользователя в системе, могут отсутствовать некоторые компоненты в системе)
4. `/var/log/` - Содержит большинство файлов журналов системы:
	- `/var/log/syslog` - Содержит сообщения от ядра и других программ и служб
	- `/var/log/apt/history.log`, `/var/log/apt/term.log` и `/var/log/dpkg.log` - все это файлы, которые помогут показать, где произошла ошибка при обновлении пакета
	- `/var/log/auth.log` - Содержит системные события авторизации.
	- `/var/log/boot.log` - Содержит сообщения, зарегистрированные во время загрузки системы.
	- `/var/log/dmesg` - Содержит информацию о кольцевом буфере ядра.
	- `/var/log/message` - Содержит системные сообщения.
	- `/var/log/lightdm/lightdm.log` - Содержит события из `lightdm`.
	- `/var/log/kern.log` - Содержит только сообщения ядра.
5. Логи пользовательских приложений (могут содержать действия пользователя), например, `/home/user/.cache/mozilla/firefox/4151u20u.default-esr/cache1/index.log`.
6. `~/` - пользовательская директория:
	- `.zsh_history` - история команд `bash`.
	- `.sudo_as_admin_successful` - файл создаётся, когда пользователь успешно выполняет команду с правами администратора (через `sudo`).
# СПОСОБЫ СОЗДАНИЯ ОБРАЗОВ
___

```bash title:"Подключение нового диска"
> $ lsblk # проверка существования диска
----
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda      8:0    0 80.1G  0 disk 
└─sda1   8:1    0 80.1G  0 part /
sdb      8:16   0    1G  0 disk 

> $ fdisk /dev/sdb # создание таблицы разделов
----
Welcome to fdisk (util-linux 2.40.2).                                        
Changes will remain in memory only, until you decide to write them.          
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS (MBR) disklabel with disk identifier 0xf76a1243.

Command (m for help): g -> w

> $ lsblk /dev/sdb # проверка создания раздела диска
----
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sdb      8:16   0    1G  0 disk 
└─sdb1   8:17   0 1022M  0 part 

> $ mkfs.[ext4] /dev/sdb1 # создание ФС
----
mke2fs 1.47.1 (20-May-2024)
Creating filesystem with 261632 4k blocks and 65408 inodes
Filesystem UUID: 00bd9d33-08b7-41b9-a010-62e91ab1f3f7
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done

> $ mkdir /mnt/test & mount /dev/sdb1 /mnt/test № создание точки подключения и непосредственно подключение

> $ df -h # проверка подключения диска

> $ echo "hello" > /mnt/test/test.txt & cat /mnt/test/test.txt # проверка работоспособности диска
```

```bash title:"MBR backup"
dd if=/dev/sda of=mbr.img bs=512 count=1
dd if=mbr.img of=/dev/sda # восстановление разделов
```
## Часть 1. Создание файловой структуры

```bash title:"Узнать тип ФС"
parted -m test/test.dd print | tail -n +3 | awk -F ":" '{print $(NF-2)}'

ИЛИ

fdisk -l ./test/test.dd или parted ./test/test.dd print

```
### 1. PhotoRec

> [!Что это]
> Утилита для восстановления удалённых файлов, входящая в состав TestDisk.

> Возможности:
> Восстановление файлов по сигнатурам (независимо от файловой системы).
> Поддержка множества форматов файлов.

```bash title:Использование
sudo photorec test_part1.dd
```
### 2. debugfs

> [!Что это]
> Утилита для работы с файловыми системами ext2/ext3/ext4. Она позволяет анализировать внутреннюю структуру файловой системы, включая каталоги и метаданные. Она позволяет работать с образом как с подключенным в данный момент диском в режиме cmd.

```bash title:Использование
debugfs ./образ_диска.dd
```
### 3. ntfsundelete

> [!Что это]
> Если работа идет с NTFS, можно использовать `ntfsundelete` для восстановления удалённых файлов и просмотра структуры каталогов.

```bash title:Использование
ntfsundelete ./образ_диска.dd -l
```
### 4. [fls](https://kali.tools/?p=1811#fls) и [The SleuthKit](https://kali.tools/?p=1811)

> [!Что это]
> Самый удобный инструмент, позволяющий полностью увидеть структуру диска.

```bash title:Использование
fls -r -p disk_image.dd
```
## Часть 2. Создание физического образа диска
### 1. dd

> [!NOTE] Что делает
> Создает побайтовый образ **устройства** (для использования [[#4. fls]] лучше делать образ логического диска).

> **Преимущества:**
> - **Простота** использования.
> - Поддержка **любых типов ФС**.
> **Недостатки:**
> - Создаёт образ всего диска, даже пустые блоки, что **увеличивает размер образа**.

```bash title:Использование
dd if=/dev/sdb of=test.img bs=4M status=progress conv=sync,noerror
```
### 2. [partclone](https://partclone.org/about/)

> [!NOTE] Что делает
> Создает побайтовый образ **раздела**.

> **Преимущества**:
> - Поддержка **сжатия**.
> - **Копируются только используемые данные**, что уменьшает размер образа.
> - ext2, ext3, ext4, hfs+, reiserfs, reiser4, btrfs, vmfs3, vmfs5, xfs, jfs, ufs, ntfs, fat (12/16/32), exfat и другие.

```bash title:Установка
apt install partclone

ИЛИ

https://github.com/Thomas-Tsai/partclone
```

```bash title:Использование
partclone.ext4 -c -s /dev/sdb1 -o img.img
```
### 3. [fsarchiver](https://www.fsarchiver.org/)

> [!NOTE] Что делает
> Создает копию ФС **со сжатием в архив**. Архив отличается от образа тем, что его можно распаковать на любом компьютере и накопителе, в том числе меньшего размера, чем оригинальный. 
> [Клонирование NTFS](https://www.fsarchiver.org/cloning-ntfs/) декларируется как сугубо **экспериментальная функция**.

> **Преимущества**:
> - несколько ФС на архив,
> - архивация ФС вместе с загрузчиком,
> - контрольные суммы для всего контента (заголовки, блоки данных, целые файлы),
> - восстановление повреждённого архива,
> - extfs, xfs, btrfs, reiserfs и т. д.), поддержка файловых систем FAT,
> - многопоточное сжатие lzo, gzip, bzip2, lzma/xz (самый медленный вариант — lzma/xz с максимальным уровнем компрессии). [Habr](https://habr.com/ru/companies/ruvds/articles/694486/)

```bash title:Установка
apt install fsarchiver

ИЛИ

https://github.com/fdupoux/fsarchiver
```

```bash title:Использование
fsarchiver savefs img.fsa /dev/sdb1

fsarchiver savefs img.fsa /dev/sda1 /dev/sda2 # Архивация нескольких файловых систем в один файл

fsarchiver restfs img.fsa id=1,dest=/dev/sdb1 # Восстановление второй (id=1) файловой системы из архива
```
### 4. [partimage](https://www.partimage.org/)

> [!NOTE] Что делает
> Создает побайтовый образ **раздела**.

> **Преимущества**:
> - Поддержка **сжатия**.
> - Поддерживаются ФС: Ext2, Ext3, Reiserfs, FAT12, FAT16, FAT16B, FAT32, HPFS, JFS, Xfs, UFS, HFS and Ntfs (экспериментально).

```bash title:Установка
sudo apt install partimage

ИЛИ

https://github.com/NVieville/partimage
```

```bash title:Использование
partimage # далее следовать инструкциям грфического интерфейса

ИЛИ

partimage save /dev/sdb1 img.img
```
### 5. [CloneZilla](https://clonezilla.org/)

> [!Что это]
> Инструмент для создания образов дисков и разделов, работающий в режиме **LiveCD**.

> *Особенности:*
> **Поддержка множества файловых систем**: (1) ext2, ext3, ext4, reiserfs, reiser4, xfs, jfs, btrfs (тестирование), f2fs и nilfs2 для GNU / Linux, (2) FAT12, FAT16, FAT32, exFAT и NTFS для MS Windows, (3) HFS + и APFS для Mac OS, (4) UFS для FreeBSD, NetBSD и OpenBSD, (5) minix для Minix и (6) VMFS3 и VMFS5 для VMware ESX ..
> Возможность создания образов **на локальный диск, сетевой ресурс или внешний накопитель**.
> Поддержка **сжатия** и **разделения образов** на части.

[Инструкция (GUI)](https://losst.pro/klonirovanie-diska-clonezilla)
### 6. tar

> [!Что такое]
> Утилита для создания архивов, которая также может использоваться для резервного копирования файловой системы.

> Преимущества:
> Поддержка сжатия.
> Возможность исключения определённых файлов или каталогов.

```bash
tar -cvzf backup.tar.gz --exclude=/backup.tar.gz --one-file-system /смонтированная_система

c - создать новый резервный архив;
v - подробный режим, при котором выводится информация о текущих действиях;
z - сжать с помощью утилиты gzip;
f <имя_файла> - полное имя файла с резервной копией.
--exclude=<имя_файла> - имена файлов или каталогов, которые необходимо исключить из резервной копии. Важно: во избежании ошибок обязательно нужно исключить файл с резервной копией.
--one-file-system - создать копию только одной файловой системы, т.е. если у вас есть смонтированные носители с другими файловыми системами, то они не будут включены в копию, их необходимо резервировать отдельно или использовать дополнительные опции.
/смонтированная_система - в конце нужно указать каталог, запасную копию которого необходимо создать.

```
Восстановление архива:
```bash
tar -xvzf <имя_файла> -C <имя_каталога> --numeric-owner

-C <имя_каталога> - каталог в который произойдет восстановление;
--numeric-owner - опция позволяет восстановить пользователей файлов по числовому дескриптору, а не по имени, во избежании ошибок.
```
## Часть 3. Исследование ФС на основе дампа памяти Windows (MemProcFS)

```bash
mkdir memProcFS && cd memProcFS
wget https://github.com/ufrisk/MemProcFS/releases/download/v5.14/MemProcFS_files_and_binaries_v5.14.3-linux_x64-20250212.tar.gz
tar -xvf ./MemProcFS_files_and_binaries_v5.14.3-linux_x64-20250212.tar.gz

./memprocfs -f dump.raw -forensic 1 -mount / # в директории / находится информация о задействованных в работе системы файлах
```
# "ДВОЙНОЕ ДНО" ФАЙЛОВ И СИСТЕМЫ (любые системы)
---
> [!Важно]
> **"Двойное дно"** - это механизм, при котором ФС или отдельное приложение предоставляет два разных представления данных: одно для сторонних пользователей, а другое - для пользователя контейнера. Это может быть использовано для *сокрытия данных*, *обхода ограничений* или *реализации дополнительных функций*, таких как шифрование, сжатие или журналирование. В частном случае данный механизм **может применяться для сокрытия данных**, когда пользователь не желает, чтобы определенная информация была раскрыта, и ставит разные условия доступа к каждой из них.
> Важно отметить, что скрытые контейнеры подходят для ХРАНЕНИЯ файлов, а не для записи в них новых данных, поскольку и его содержимое, и его "разметка" в противном случае будет перезаписаны и впоследствии повреждены. Зачастую **определить, что в контейнере находятся два таких же контейнера**, но с разными правилами доступа к ним, **невозможно**.
## Часть 1. "Двойное дно" файлов

> [!Суть работы]
> Использоваться могут различные инструменты, пример будет приведен на приложении **VeraCrypt**. Суть заключается в том, чтобы был создан новый зашифрованный файл-контейнер, выглядящий как обычный файл, внутри которого будет расположено два хранилища: один - для сторонних пользователей, другой - для сокрытия данных. Таким образом, даже если будет выявлено наличие контейнера, будет вероятность того, что реально секретные данные не будут раскрыты.

7. Создаем зашифрованный файл-контейнер (скрытый том VeraCrypt) через создание и монтирование тома, указание его размера.
![[Pasted image 20250221224812.png|Шаг 1]]
![[Pasted image 20250221224900.png]]
![[Pasted image 20250221224947.png]]
![[Pasted image 20250221225006.png]]
![[Pasted image 20250221225029.png]]
8. Создаем пароль для шифрования открытого контейнера.
![[Pasted image 20250221225213.png]]
![[Pasted image 20250221225303.png]]
9. Заполнение открытого контейнера данными.
![[Pasted image 20250221225345.png]]
![[Pasted image 20250221225454.png]]
10. Задание параметров для скрытого контейнера. Процесс полностью аналогичен созданию открытого контейнера, но на этом этапе пароль для контейнера должен отличаться от пароля для открытого контейнера. 
![[Pasted image 20250221225837.png]]
11. Монтирование скрытого контейнера и первичное размещение файлов.
![[Pasted image 20250221230410.png]]
На этом этапе есть готовый контейнер, который выглядит как файл с расширением `.txt`, однако не открывающийся средствами ОС, а в HEX-редакторе отображает рандомные данные, несвойственные для текстового файла с осмысленным текстом. 
![[Pasted image 20250221230717.png]]
Опытным путем было выявлено полное отсутствие коллизий между двумя полностью идентичными (созданными с одинаковыми параметрами) контейнерами, а также невозможно определить начало и конец открытых и закрытых контейнеров. Таким образом, был создан контейнер, в котором размещены два контейнера: открытый (с одним правилом доступа) и закрытый (с другим правилом доступа). При этом, учитывая механизмы шифрования, не зная пароль или другой механизм расшифрования, расшифровать оба контейнера невозможно.
## Часть 2. "Двойное дно" системы (ДДФС)

> [!Суть работы]
> Механизм работы ничем не отличается от механизма работы для файлов, только здесь основным контейнером выступает вся файловая система (зачастую, к которой также часто требуется подобрать пароль), а секретные данные помещены в скрытый раздел, и, поскольку большинство механизмов создания ДДФС и файлов перед началом создания зашифрованного контейнера заполняет целевой файл/систему случайными данными, определить, где на шифрованном диске расположен открытый раздел, а где - закрытый, невозможно.
> Помимо приведенного ниже алгоритма, также можно использовать и сторонние программы для скрытия разделов, например, тот же *VeraCrypt*.

### 1. Алгоритм создания
Подробный гайд по созданию ДДФС с помощью [тулзы](https://github.com/amateur80lvl/pdt) представлен на [хабре](https://habr.com/ru/articles/749830/). Вкратце:
12. Разбивка диска на разделы (далее - открытый и закрытый контейнеры) и форматирование на них ФС.
13. Определение задействованных секторов ФС.
	- Скачивание на съемный носитель (далее - СН) тулзы.
	- Инициализация диска (далее - контейнер) рандомными данными.
	- Вычисление хэшей секторов для анализа занимаемых системой секторов.
14. Отключение TRIM (если диск типа SSD).
15. Установка чистой системы с тулзами для шифрования и анализ контейнера на наличие задействованных секторов с помощью, например, liveUSB - для создания скрытого контейнера.
16. Установка тулзы. Здесь ключевую роль играют факторы ее [расположения](https://habr.com/ru/articles/749830/) (этот раздел на диске будет содержать конфигурацию тулзы):
	- Требуется небольшой размер на диске (до 1 Мб).
	- Может быть расположена в начале диска, например, с 34 сектора (GPT / MBR).
	- Может быть расположена в конце диска, до (-34) сектора (GPT) или в самом конце (MBR).
	- Может быть расположена на границе разделов.
	- Может быть расположена на внешнем устройстве.
17. Шифрование раздела конфигурации тулзы.
18. Монтирование определенных каталогов.
19. Монтирование секретного раздела в `/root`.
### 2. Анализ использования ДДФС
20. Отключенный TRIM (в приоритете - на SSD).
21. Строчки в `tempfs`, свидетельствующие о сокрытии использования некоторых утилит:

```bash
tmpfs  /tmp      tmpfs  nosuid,nodev,mode=1755,size=32M       0 1
tmpfs  /var/log  tmpfs  nosuid,noexec,nodev,mode=755,size=4M  0 1
```

22. Отключение истории команд, например, в `.bashrc`.
23. Использование на разделе конфигурации тулзы старой ФС, например, ext2.
24. 3. Использование секретного раздела с виртуальной машины
25. В `/etc` смонтирована `overlayfs`, а в `/home` - `tempfs` (в которой расположены пользовательские каталоги и каталоги пользователей секретного раздела), чтобы *скрыть дополнительных пользователей,* а также *другую конфигурацию*, которой в нормальной системе не должно быть.
26. Использование `overlayfs` для `/var/tmp` и `/usr/local`
27. Монтирование секретного раздела в `/root.`
   